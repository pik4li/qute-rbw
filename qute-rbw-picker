#!/usr/bin/env bash
# usercommand to pick rbw passwords with fzf
# takes in one argument $1 and this should be the tmpfile to write to
#
# gets executed by get-pw && kitty
MENU_ITEMS=(
  "-> Entries"
  "-> Quit"
  # the third entry (index 2) will be the '--> LAST' entry
)

# ─< initial variables >────────────────────────────────────────────────────────
cache_dir="${HOME}/.cache/rbwzf"
cache_file="${cache_dir}/last_entries-${USER-"$(whoami)"}" # cachefile with username in it

# checks for the rbw installation path though cargo and appends it to PATH just
if [[ -d "$HOME/.cargo/bin" ]]; then
  # to be sure
  PATH="${HOME}/.cargo/bin:${PATH}"
fi

# ─< ANSI color codes >───────────────────────────────────────────────────────────────────
RED='\033[0;31m'
NC='\033[0m' # No Color

# ──────────────────────────────── <setup traps >──────────────────────────────
on-exit() {
  local err=$?

  # INFO:
  # You can uncomment the next line, to always lock your vault uppon exiting the
  # script. Allthough this is more secure, it is also pretty nerve racking, if
  # you have to type in your password all the time.. But you decide ^^

  # rbw lock

  [[ -z "${err}" ]] || exit "$err" # exiting with the error message given
}
trap on-exit exit SIGTERM INT
# ───────────────────────────────── <traps done >─────────────────────────────────

command-exists() {
  command -v "$@" >/dev/null 2>&1
}

write-cache() {
  ((${#LAST[@]} > 0)) && {
    printf "%s\n" "${LAST[@]}" | sort -u >"$cache_file"
  }
}

# check dependencies, also checks and unlocks vault if locked
check-dependencies() {
  local clipboard
  local deps=() needs=()

  if [[ -n "${WAYLAND_DISPLAY}" ]]; then
    clipboard=wl-copy
  else
    clipboard=xclip
  fi

  deps=(
    "rbw"
    "jq"
    "sort"
    "pinentry"
    "$clipboard"
  )

  # fill in the needs=() array if packages are missing
  for pkg in "${deps[@]}"; do
    if ! command-exists "${pkg}"; then
      needs+=("${pkg/wl-copy/wl-clipboard}")
    fi
  done

  if ! command-exists sk && ! command-exists fzf && ! command-exists gum; then
    needs+=("sk || fzf || gum")
  fi

  # if array is not empty, then exit and inform the user
  if ((${#needs[@]} > 0)); then
    printf "You do not have ${RED}%s${NC} installed on your system, please install before going on" "${needs[*]}"
    exit 69
  fi

  # unlock vault if it's locked
  if ! rbw unlocked >/dev/null; then
    rbw unlock >/dev/null
  fi

  rbw sync >/dev/null

  if [[ ! -e "${cache_file}" ]]; then
    mkdir -p "${cache_dir}"
    touch "${cache_file}"
  fi
}

add-last() {
  local arg=$1 arr=() append=true

  # Skip menu items (anything starting with "->")
  if [[ "${arg}" == "->"* ]]; then
    return
  fi

  arr=("${LAST[@]}")
  local length="${#arr[@]}"

  # Check for exact match in LAST array
  for ((i = 0; i < length; i++)); do
    if [[ "${arg}" == "${arr[$i]}" ]]; then
      append=false
      break
    fi
  done

  if $append; then
    LAST+=("$arg")
    write-cache
  fi
}

# print * for every char in the given length
for-pw() {
  local length=${1:-}

  for ((i = 0; i < length; i++)); do
    printf "*"
  done
}

fzf-cmd() {
  # defines the fzf-cmd, since fzf on different version has different flags to
  # enable.. Also tries to use a pretty fzf scheme. Also uses sk if it's there and
  # the fzf_version could not get determined
  local fuzz="" cmd

  local fuzzer=(
    sk
    fzf
    gum
  )

  for cmd in "${fuzzer[@]}"; do
    if ! command-exists "$cmd"; then
      continue
    fi

    fuzz=$cmd
    break
  done

  local fzf_version label
  label=$1

  case "${fuzz}" in
  fzf)
    # Extract version number (strip any commit hash, etc.)
    fzf_version=$(fzf --version 2>/dev/null | awk '{print $1}')

    # Check if fzf_version >= 0.58.0
    if [[ "$(printf '%s\n' "0.58.0" "$fzf_version" | sort -V | head -n1)" == "0.58.0" ]]; then
      if ((${#label} == 0)); then
        fzf --reverse --style=full:rounded --margin 12% --color 16 --cycle --no-multi
      else
        fzf --reverse --style=full:rounded --margin 12% --color 16 --cycle --no-multi --input-label "${label}"
      fi
    else
      fzf --margin 12% --color 16 --cycle --no-multi --reverse
    fi

    return
    ;;
  sk)
    sk --margin 12% --color 16 --reverse # sk|skim is a rust filepicker simmilar like fzf

    return
    ;;
  gum)
    gum filter --fuzzy --fuzzy-sort --placeholder="Select a password entry.."
    ;;
  esac
}

fzf-resolve() {
  local arg=$1

  [[ -n "${arg}" ]] || exit 68

  case "${arg}" in
  *[Ee]ntries) fzf-entries ;;
  *[Mm]enu) fzf-menu ;;
  *[Ll]ast*)
    if ((${#LAST[@]} >= 1)); then
      # if [[ -n "${LAST}" ]]; then
      least=$(get-opts "${LAST[@]}" "${MENU_ITEMS[@]}")
      fzf-resolve "${least}"
      fzf-show "${least}"
      # fzf-show "${LAST}"
    else
      echo "There is no last password in \$LAST.." && sleep 5
    fi
    ;;
  Add) ;;
  Remove) ;;
  *Quit) exit 0 ;;
  esac
}

get-opts() {
  local labels opt arr=()
  # get options with fzf command directly
  # just assign variable with the get-opts + any array or just write your own
  # e.g.
  # var=$(get-opts "this" "gets" "displayed" "as" "options")
  # can also take in lables, with the "!_label_:" prefix, everything after :
  # will get displayed in the input-label box (required fzf 0.58 and higher)

  # if there is a '!_label_:' prefix, then use it!
  if [[ "${1}" =~ "!_label_:" ]]; then
    labels=$1
    shift
    local arr=("$@")
    labels=${labels#!_label_:} # remove the prefix we searched for

    {
      for opt in "${arr[@]}"; do
        printf "%s\n" "${opt}"
      done
    } | fzf-cmd "${labels}"
  else
    arr=("$@")
    {
      for opt in "${arr[@]}"; do
        printf "%s\n" "${opt}"
      done
    } | fzf-cmd
  fi
}

setup-bootstrap() {
  local domain="" mail="" check_mail="" check_url="" data=""
  data="$(rbw config show)"

  check_mail=$(jq -r .email <<<"${data}")
  check_url=$(jq -r .base_url <<<"${data}")

  if [[ -z "${check_mail}" ]] || [[ -z "${check_url}" ]]; then
    # ─< if mail or url is not set, then ask for it and set it! >───────────────────
    [[ -n "${check_mail}" ]] || {
      read -r -p "Type in the mail for your account - mail: " mail

      if [[ "${mail}" =~ ^(.*@.*)$ ]]; then
        rbw config set email "${mail}"
      else
        echo "Your mail $mail was formatted incorrectly.."
      fi
    }

    [[ -n "${check_url}" ]] || {
      read -rp "Type in the domain your bitwarden is hosted - (https:// is automatically appended) - domain: " domain
      domain=${domain#https://} # sanitize name
      domain=${domain#http://}  # sanitize name
      domain=${domain%%/*}      # sanitize name

      rbw config set base_url "https://${domain}"
    }
  fi

  # setup the LAST array with the cache input
  if [[ -f "${cache_file}" ]]; then
    while IFS= read -r line; do
      [[ -n "$line" ]] && LAST+=("$line")
    done <"$cache_file"
  else
    LAST=()
  fi
}

fzf-paste() {
  local entry=$1
  local file=$2
  local arr=() data opt entry_name username password option output name folder

  data="$(rbw get "${entry}" --raw)"

  name=$(jq -r .name <<<"${data}")
  folder=$(jq -r .folder <<<"${data}")
  username=$(jq -r .data.username <<<"${data}")
  password=$(jq -r .data.password <<<"${data}")
  otp=$(jq -r .data.totp <<<"${data}")

  if [[ "${otp}" != "null" ]]; then
    totp=$(rbw code "${entry}")
  fi

  if [[ -n "${folder}" ]]; then
    entry_name="${name} ( ${folder})"
  else
    entry_name="${name}"
  fi

  [[ -n "${username}" ]] && [[ "${username}" != "null" ]] && arr+=("Username: ${username}")
  [[ -n "${password}" ]] && [[ "${password}" != "null" ]] && arr+=("Password: $(for-pw ${#password})")
  [[ -n "${totp}" ]] && arr+=("OTP:      ${totp}")
  arr+=("${MENU_ITEMS[@]}")

  option=$(get-opts "!_label_:${entry_name} - Select to paste:" "${arr[@]}") # what to paste to qutebrowser input field
  fzf-resolve "${option}"

  case "${option}" in
  Password:*)
    output=${password}
    ;;
  Username:*) output=${username} ;;
  OTP:*) output=${totp} ;;
  *)
    exit 69
    ;;
  esac

  # get the output into the file for qutebrowser
  # Write password/TOTP on separate lines if TOTP exists
  if [[ -n "${totp}" ]]; then
    printf "%s\n%s" "${output}" "${totp}" >"$file"
  else
    printf "%s" "${output}" >"$file"
  fi
  # exit
}

fzf-entries() {
  local data entry_name username password otp
  local file=$1

  ((${#LAST[@]} > 0)) && MENU_ITEMS[2]="-> Last (${#LAST[@]})"

  local entry
  entry=$(
    {
      printf "%s\n" "${MENU_ITEMS[@]:1:2}" # only show quit and last entries, if available
      rbw ls
    } | fzf-cmd "Select entry:"
  )

  # resolve fzf menu options
  fzf-resolve "${entry}"
  add-last "${entry}"
  fzf-paste "${entry}" "${file}"
}

# check dependencies
check-dependencies
setup-bootstrap

## debug
# echo "" >/tmp/qute-rbw-debug.log
# echo "WAYLAND_DISPLAY: $WAYLAND_DISPLAY" >>/tmp/qute-rbw-debug.log
# echo "DISPLAY: $DISPLAY" >>/tmp/qute-rbw-debug.log
# echo "PID: $$" >>/tmp/qute-rbw-debug.log

# passes $1 (the tmpfile) into the next functioncall (fzf-paste) where it gets pasted into the tmpfile
fzf-entries "$1"
